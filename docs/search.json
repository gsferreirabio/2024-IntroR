[
  {
    "objectID": "yourfunction.html",
    "href": "yourfunction.html",
    "title": "Writing your functions",
    "section": "",
    "text": "Maybe you want to automatize a process for which you cannot find an already written function, or maybe you want to customize a function to your needs. R enables you to write your own functions using function() and defining the set of steps that will be performed by this function. Of course, they can be stored in objects, which will then be treated as the names of your functions.\nLet’s create a function to calculate the median of a distribution. The median is a value that separates the distribution in half. In a distribution with an odd number of elements, the element in the center of this distribution (when sorted from minimum to maximum or the opposite) is the median.\n\nodd.dist &lt;- c(1, 3, 5, 7, 9)\nlength(odd.dist)/2\n\n[1] 2.5\n\n# because this is not an integer, we will round it upwards\nodd.dist[ceiling(length(odd.dist)/2)]\n\n[1] 5\n\n\nThis becomes a bit more difficult when the distribution has an even number of elements, because there is no single position at the middle. What is done then is to calculate the average between the values in the two positions before and after the center of the distribution.\n\neven.dist &lt;- c(2, 4, 6, 8)\nmedian(even.dist)  \n\n[1] 5\n\n\nFive is not a number in the even.dist, but is the mean between 4 and 6. Thus, a function to calculate the mean will require four steps: 1. order the sequence 2. check whether the sequence is even or odd 3a. if it is odd, select the number in the center position 3b. if it is even, calculate the mean between the numbers before and after the center position\nIt is always useful to check if each step in your code successfully runs by itself. Let’s do this:\n\n# Step 1: Order the sequence\nnew.seq &lt;- c(1, 5, 3, 9, 7, 11)\nsort(new.seq)\n\n[1]  1  3  5  7  9 11\n\n# Step 2: Odd or even?\nlength(even.dist)%%2 == 0  ## dividing even.dist by 2 leaves nothing\n\n[1] TRUE\n\nlength(odd.dist)%%2 == 0\n\n[1] FALSE\n\n# Step 3a: if odd, select the number in the center position\nodd.dist[length(odd.dist)/2]\n\n[1] 3\n\n# Step 3b: if even, calculate the mean between the numbers before \n## and after the center position\nbef &lt;- even.dist[length(even.dist)/2]\naft &lt;- even.dist[1 + length(even.dist)/2]\n(bef + aft)/2\n\n[1] 5\n\n\nNow we can put all those steps together in a single function and use it to calculate the median of the new.seq and the even.dist objects.\n\ncalculate.median &lt;- \n  function(x) {\n    odd.even &lt;- length(x)%%2\n    ## we are going to use if/else statements\n    if (odd.even == 0) {  \n      (sort(x)[length(x)/2] + sort(x)[1 + length(x)/2])/2\n    }\n    else sort(x)[ceiling(length(x)/2)]\n  }\n\ncalculate.median(new.seq)\n\n[1] 6\n\ncalculate.median(even.dist)\n\n[1] 5\n\n\nFinally, you might want to save this function so that you can load it in another script, without the need to rewriting it all over. To save and load a function (or any object, actually), use:\n\nsave(calculate.median, file = \"calculate.median.R\")\n\n# and to load it in another session\nload(file = \"calculate.median.R\")",
    "crumbs": [
      "Day 02",
      "Writing your functions"
    ]
  },
  {
    "objectID": "Rascalculator.html",
    "href": "Rascalculator.html",
    "title": "R as a calculator",
    "section": "",
    "text": "R is a very complete calculator that allows you to perform from simple arithmetic operations to solve complex equations. The basic arithmetic operators for addition, subtraction, multiplication and division in R are:\n\n2+2  ## addition\n\n[1] 4\n\n2-2  ## subtraction\n\n[1] 0\n\n2*2  ## multiplication\n\n[1] 4\n\n2/2  ## division\n\n[1] 1\n\n\nYou can pass multiple operations in a single line of code, but keep in mind that some operators have priorities over others, so use parameters to keep the desired operation order.\n\n2+3+5+10+25-2  ## multiple operations\n\n[1] 43\n\n2+3*4  ## multiplications and divisions are done first\n\n[1] 14\n\n2+10/5\n\n[1] 4\n\n3^2/2  ## but power comes first\n\n[1] 4.5\n\n# Parenthesis are useful to determine the order of operations\n3^(2/2)\n\n[1] 3\n\n\nR deals with large numbers using the e character followed by the number of positions the decimal point will move. If the number is positive, the decimal point moves to the right; if negative it moves to the left.\n\n1.2e3 \n\n[1] 1200\n\n1.2e-2 \n\n[1] 0.012\n\n\n\nLogical operators\nBoolean algebra (operations that return True or False values) can be done using the == (double equal signs = “equals to”) and != (“not” operator (!) followed by equal sign = “differs from”) logical operators:\n\n1 == 1\n\n[1] TRUE\n\n1 == 2\n\n[1] FALSE\n\n1 != 1\n\n[1] FALSE\n\n1 != 2\n\n[1] TRUE\n\n\nThe returned values from Boolean operations are TRUE and FALSE (always in capital letters), which can also be expressed by the single capital letters T and F, respectively.\n\nT == TRUE\n\n[1] TRUE\n\nF == FALSE\n\n[1] TRUE\n\n\n“Greater than” (&gt;), “smaller than or equal to” (&lt;=), “and” (&), “or” (|) are all logical operators that can be used in R.\n\n1 & 2 &gt; 3  ## 1 and 2 are greater than 0\n\n[1] FALSE\n\n1 | 10 &lt;= 5  ## 1 or 10 is smaller or equal to 5\n\n[1] TRUE\n\n\n\n\nAdditional signs\nTwo dots (:) can be used to create a sequence.\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n2.5:5.5\n\n[1] 2.5 3.5 4.5 5.5\n\n\nAnd the modulo operation (the remainder of a division) can be done using “%%”:\n\n2%%2\n\n[1] 0\n\n3%%2\n\n[1] 1\n\n\n\n\nMissing and null values\nMissing values in R are represented by the special object NA (“not available”). NAs reserve space in a vector, which is important to keep the original dimensions, but they can be very annoying when using some functions. We will see how to identify and deal with them in the Functions section. On the other hand, the special object NULL represents the absence of a value and indicates that an object contains no data. It can be used for example to create an object that will be fill with values later in a function to to remove the content of a preexisting object.",
    "crumbs": [
      "Day 01",
      "R as a calculator"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction To R",
    "section": "",
    "text": "Welcome to the website of the Introduction to R course (Geow-M317_325-21-16). This short course is part of the Data Analysis and Modeling Methods in Geoscience and Environmental Science module of the Geosciences Department (Uni. Tübingen) and is developed and taught by Gabriel Ferreira.\nThe Intro to R course aims to provide a brief introduction to using the R programming language and environment in a data science context, particularly for students in the areas of Geology and Palaeontology. With a lot of hands-on exercises, the students are expected to feel comfortable to use and explore the many possibilities provided by R.\nYou can use the sidebar to navigate through the different code presented in each day of the course.\nWe will use the RStudio integrated development environment (IDE) for R during this course. You can either install on your own machine or create a free account to use the cloud version of it (but keep in mind that the computing power and hours are limited with the free account, so this might not be enough — particularly in the last days of the course). Make sure to update R (https://cran.r-project.org/bin/windows/base/) and RStudio (https://posit.co/download/rstudio-desktop/) as this page will be kept up-to-date using the latest version.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions",
    "section": "",
    "text": "Using functions is a great way to generalize and automatize processes. R comes with several basic functions implemented in packages (which are basic collections of functions and objects) such as stats and graphics. Functions will usually take arguments provided by the user based on which they will perform an action. It is always important to read the Help page of a function to learn which arguments are possible and how to use them.\nFor example, you can use a function to generate a sequence more complex than just by using 1:10 using the arguments by and length.out of the function seq:\n\nseq(from = 1, to = 20, by = 2)  ## increment the sequence by 2\n\n [1]  1  3  5  7  9 11 13 15 17 19\n\nseq(from = 1, to = 20, length.out = 5)  ## only 5 numbers between 1 and 20\n\n[1]  1.00  5.75 10.50 15.25 20.00\n\n\nA sequence can also be created by repetitions using the function rep and defining arguments as each (each element is repeated x times) and times (the sequence is repeated x times).\n\nrep(1:4, each = 2)\n\n[1] 1 1 2 2 3 3 4 4\n\nrep(c(\"cat\", \"dog\", \"mouse\"), times = 2)\n\n[1] \"cat\"   \"dog\"   \"mouse\" \"cat\"   \"dog\"   \"mouse\"\n\nrep(c(\"cat\", \"dog\", \"mouse\"), times = 1:3)\n\n[1] \"cat\"   \"dog\"   \"dog\"   \"mouse\" \"mouse\" \"mouse\"\n\n\nWe saw before that a logical operation can be made for each element in a vector using logical operators. If you want to check whether all or any elements fit a certain criterium you can use the functions:\n\nvec.1 &lt;- c(2, 4, 6)\nall(vec.1&lt;4)\n\n[1] FALSE\n\nany(vec.1&lt;4)\n\n[1] TRUE\n\n\nThe base packages in R also include functions to perform more complex but very useful calculations, such as logarithms (with different bases) and antilogs, square roots, sums, means and medians.\n\nlog(42)  ## natural log\n\n[1] 3.73767\n\nlog10(42)  ## base 10 log\n\n[1] 1.623249\n\nexp(3.73767)  ## antilog\n\n[1] 42.00002\n\nX = 13^2\nsqrt(X) == 13\n\n[1] TRUE\n\nvec &lt;- seq(1, 100, by = 2)\nsum(vec)\n\n[1] 2500\n\nmean(vec)\n\n[1] 50\n\nmedian(vec)\n\n[1] 50\n\n\nChecking the range of values in a list, the minimum and maximum values, and the length of this list can be very useful. As well as sorting a list or selecting which values correspond to a criterium.\n\nrange(vec)\n\n[1]  1 99\n\nmax(vec)\n\n[1] 99\n\nmin(vec)\n\n[1] 1\n\nlength(vec)\n\n[1] 50\n\nsort(vec)\n\n [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49\n[26] 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99\n\nrev(vec)\n\n [1] 99 97 95 93 91 89 87 85 83 81 79 77 75 73 71 69 67 65 63 61 59 57 55 53 51\n[26] 49 47 45 43 41 39 37 35 33 31 29 27 25 23 21 19 17 15 13 11  9  7  5  3  1\n\nwhich(vec == 3)  ## gives the position in the list\n\n[1] 2\n\n\nWe saw before how to see the class of an object using the class() function, but we can also check whether an object is from a specific class using the group of functions “is.X”:\n\nis.numeric(vec)\n\n[1] TRUE\n\nis.character(vec)\n\n[1] FALSE\n\n\nFactor is an object type that represent categorical variables. They have a determined number levels (categories), and some functions can be used to check those.\n\ncolor.names &lt;- factor(c(\"black\", \"white\", \"pink\", \"pink\", \"white\", \"white\"))\nclass(color.names)\n\n[1] \"factor\"\n\nlength(color.names)\n\n[1] 6\n\nlevels(color.names)\n\n[1] \"black\" \"pink\"  \"white\"\n\nlength(levels(color.names))\n\n[1] 3\n\n# there is also a function to do that\nnlevels(color.names)\n\n[1] 3\n\n\nLet’s say you want to calculate the mean value of a sequence that contains NA. This will return an NA:\n\ny &lt;- c(4, NA, 7)\nmean(y)\n\n[1] NA\n\n\nSo, you need to deal with this NA before obtaining this mean value. You can identify its position and manually remove it, but this becomes impracticable as the dimensions of an object increase. You can replace the NA by another value, using the ifelse() function, but that will change the original data. Alternatively, you can omit the NAs from the calculation, either before (using the function na.omit()) or with an argument implemented in the mean() function:\n\n# Option 1. Manually removing NAs. Try to understand the series of code here\nis.na(y)  ## tells you which positions are NAs\n\n[1] FALSE  TRUE FALSE\n\ny[!is.na(y)]\n\n[1] 4 7\n\ny.removed &lt;- y[!is.na(y)]  \ny.removed\n\n[1] 4 7\n\nmean(y.removed)\n\n[1] 5.5\n\n# Option 2. Replacing NAs\ny.replaced &lt;- ifelse(test = is.na(y), yes = 0, no = y) \ny.replaced\n\n[1] 4 0 7\n\nmean(y.replaced)\n\n[1] 3.666667\n\n# Option 3. Omitting NAs\ny.omit &lt;- na.omit(y)\ny.omit\n\n[1] 4 7\nattr(,\"na.action\")\n[1] 2\nattr(,\"class\")\n[1] \"omit\"\n\nmean(y.omit)\n\n[1] 5.5\n\n# Option 4. Use an argument in mean()\nmean(y, na.rm = TRUE)\n\n[1] 5.5\n\n\nOn the next section we will see how you can write your own function.\n\nPackages\nIn this section we will install and load packages to use their functions. Packages available on the official R repository (the CRAN repository) can be installed using the function:\n\ninstall.packages(\"ggplot2\")\n\nInstalling a package does not make it readly available, they first need to be loaded on the session.\n\nlibrary(ggplot2)\n\nWarning: package 'ggplot2' was built under R version 4.3.3",
    "crumbs": [
      "Day 01",
      "Functions"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "gettinghelp.html",
    "href": "gettinghelp.html",
    "title": "Getting help",
    "section": "",
    "text": "The first place to get help with R is the Comprehensive R Archive Network, where you can find many resources about R, such as manuals and FAQs, and also general announcements from the developers.\nDirectly in RStudio you can open the Help page (on the Help tab, usually on the bottom right panel) by running “?” followed by the name of the function or package:\n\n?read.table\n\nIf you cannot remember the exact name of a function, but remember its subject, you can use the help.search() function passing what you remember as an argument.\n\nhelp.search(\"csv\")  ## then use ? read.table for more precise info\n\nThe function find() finds which package a given function is in (more on packages and functions later); apropos() returns the objects and functions that match the argument you pass to it; example() and demo() take function names as arguments and are useful to learn how those functions work.\n\n# Try using those functions\nfind(\"max\")\n\napropos(\"lm\")\n\nexample(lm)\ndemo(graphics)\n\nFinally, knowing the version of R you are using and how to cite it (do not forget to cite it!) are always useful and can be done as follows:\n\nversion\n\n               _                                \nplatform       x86_64-w64-mingw32               \narch           x86_64                           \nos             mingw32                          \ncrt            ucrt                             \nsystem         x86_64, mingw32                  \nstatus                                          \nmajor          4                                \nminor          3.0                              \nyear           2023                             \nmonth          04                               \nday            21                               \nsvn rev        84292                            \nlanguage       R                                \nversion.string R version 4.3.0 (2023-04-21 ucrt)\nnickname       Already Tomorrow                 \n\ncitation()\n\nTo cite R in publications use:\n\n  R Core Team (2023). _R: A Language and Environment for Statistical\n  Computing_. R Foundation for Statistical Computing, Vienna, Austria.\n  &lt;https://www.R-project.org/&gt;.\n\nA BibTeX entry for LaTeX users is\n\n  @Manual{,\n    title = {R: A Language and Environment for Statistical Computing},\n    author = {{R Core Team}},\n    organization = {R Foundation for Statistical Computing},\n    address = {Vienna, Austria},\n    year = {2023},\n    url = {https://www.R-project.org/},\n  }\n\nWe have invested a lot of time and effort in creating R, please cite it\nwhen using it for data analysis. See also 'citation(\"pkgname\")' for\nciting R packages.",
    "crumbs": [
      "Day 01",
      "Getting help"
    ]
  },
  {
    "objectID": "objects.html",
    "href": "objects.html",
    "title": "Objects and variables",
    "section": "",
    "text": "Of course R is more than a simple calculator. The great benefit of using such a language is being able to store the results of an operation into a variable (or an object) that can be used later in some subsequent operation or passed as an argument in a function. In R you can do that using either “&lt;-” (which passes the value from the right to the left; shortcut: Alt + -) or the “=”. They have the same effect, but keeping the usage of “=” for operations or passing a value as an argument and “&lt;-” for storing values in an object is usually better seen. Whatever you choose to use, keep it consistent.\nAn object in R is stored in the environment and can be accessed by just typing its name. An object can store anything, a number, a character string, a vector or list, a matrix or data frame, even functions. Keep in mind that R is case-sensitive! The class of an object can be checked using the class() function.\n\nY = 2\ny = 1\nY == y\n\n[1] FALSE\n\nclass(y)\n\n[1] \"numeric\"\n\nanswer = \"Y is not the same as y\"\nanswer\n\n[1] \"Y is not the same as y\"\n\nclass(answer)\n\n[1] \"character\"\n\nsequence &lt;- 1:10\nsequence\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nclass(sequence)\n\n[1] \"integer\"\n\nclass(class)\n\n[1] \"function\"\n\n\nOperations can be done with objects instead of numbers (such as Y == y above). You can also combine objects into different objects. For example, to create a matrix (2-dimensions object), you can combine two vectors (1D objects) using functions like rbind or cbind (check their Help pages using ?rbind. Check also the function c()).\n\nvec.1 &lt;- c(2, 4, 6)\nvec.2 &lt;- c(3, 5, 7)\nmatrix.1 &lt;- cbind(vec.1, vec.2)  ## binds by column\nmatrix.1\n\n     vec.1 vec.2\n[1,]     2     3\n[2,]     4     5\n[3,]     6     7\n\nmatrix.2 &lt;- rbind(vec.1, vec.2)  ## binds by row\nmatrix.2\n\n      [,1] [,2] [,3]\nvec.1    2    4    6\nvec.2    3    5    7\n\nvec.1 + vec.2\n\n[1]  5  9 13\n\nvec.1 &gt; 4\n\n[1] FALSE FALSE  TRUE\n\n\nThere is another class of objects in R called data frames that are used a lot by many functions due to its capacity of storing different data types and to have your dimensions changed after creation. For example, you cannot have one column with character strings and another with numbers in a matrix (it will convert the columns to the same type), but you can have that with a data frame. You can access single columns, rows or cells by using the row and/or column number between square brackets.\n\nvec.3 = c(\"A\", \"B\", \"C\")\ncbind(vec.3, vec.2)\n\n     vec.3 vec.2\n[1,] \"A\"   \"3\"  \n[2,] \"B\"   \"5\"  \n[3,] \"C\"   \"7\"  \n\ndf &lt;- data.frame(vec.3, vec.2)\ndf\n\n  vec.3 vec.2\n1     A     3\n2     B     5\n3     C     7\n\ndf[1,1]  ## row 1, column 1\n\n[1] \"A\"\n\ndf[,2]  ## column 2\n\n[1] 3 5 7\n\n\nA nice feature of a data frame is giving names to its columns and then calling them using the $ sign.\n\ncolnames(df) &lt;- c(\"characters\", \"numbers\")\ndf$characters\n\n[1] \"A\" \"B\" \"C\"\n\ndf$numbers\n\n[1] 3 5 7",
    "crumbs": [
      "Day 01",
      "Objects and variables"
    ]
  },
  {
    "objectID": "syntax.html",
    "href": "syntax.html",
    "title": "Basic syntax",
    "section": "",
    "text": "To use R you need to pass a series of commands to the console that will perform the analyses you want. Instead of just remembering everything you’ve done and typing the commands directly on the console, it is useful to use a text editor and create a script, in which you can keep track of what you want to do. RStudio has a built-in text editor that highlights the different elements used in R language, so it can be very useful. With it you can type all the functions and commands you need and save them in a .R script format. But you can also use any other text editors you like and have your script saved as a .txt file instead. As long as you pass the commands to the console, everything is fine. From now one, we will be using the RStudio text editor.\nEverything you type in the script can be interpreted either as code, unless you tag it as code:\n\n# This is how you type a comment. The following is code:\n\n2 + 2\n\n[1] 4\n\n\nCode should be thought and written in a self-explanatory manner. But, at least when you are learning, commenting your code will be very helpfult to remember what (and how) you did before. It is also very useful to keep a cohesive and clean code. Use for example a series of hashtags (#) to create section breakers with titles, and also try to avoid very long lines, breaking the code when possible.\n\n################################################################################\n# This is a new section\n\n# Instead of writing like this:\nplot(x = SCL, y = SCm, log = \"xy\", main = \"Skull vs. carapace length in Chelidae\", xlab = \"Carapace length (SCL)\", ylab = \"Skull lenght (SCm)\", bty = \"l\", cex = 0)\n\n# Try like this\nplot(x = SCL, \n     y = SCm, \n     log = \"xy\", \n     main = \"Skull vs. carapace length in Chelidae\",\n     xlab = \"Carapace length (SCL)\",\n     ylab = \"Skull lenght (SCm)\", \n     bty = \"l\",\n     cex = 0)",
    "crumbs": [
      "Day 01",
      "Basic syntax"
    ]
  }
]